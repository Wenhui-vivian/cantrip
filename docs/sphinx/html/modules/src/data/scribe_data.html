
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>src.data.scribe_data &#8212; CANTRIP 0.1.0 documentation</title>
    <link rel="stylesheet" href="../../../static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../static/jquery.js"></script>
    <script type="text/javascript" src="../../../static/underscore.js"></script>
    <script type="text/javascript" src="../../../static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for src.data.scribe_data</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Contains classes and methods for parsing and representing chronologies.</span>

<span class="sd">Attributes:</span>
<span class="sd">    _UNK (str): Module level private-variable containing the unknown token symbol</span>
<span class="sd">    DELTA_BUCKETS (List[int]): list of temporal windows (in days) used for discrete delta encoding</span>

<span class="sd">Todo: Find a better way to represent delta encoder range dimensionality</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Text</span><span class="p">,</span> <span class="n">Iterable</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">src.models</span> <span class="k">import</span> <span class="n">CANTRIPModel</span>

<span class="c1"># Symbol used to denote unknown or out-of-vocabulary words</span>
<span class="n">_UNK</span> <span class="o">=</span> <span class="s1">&#39;UNK&#39;</span>

<span class="c1"># Discrete time windows used when discretizing deltas (windows defined in days since prev. snapshot)</span>
<span class="n">DELTA_BUCKETS</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="mi">182</span><span class="p">,</span> <span class="mi">365</span><span class="p">,</span> <span class="mi">730</span><span class="p">]</span>


<div class="viewcode-block" id="encode_delta_discrete"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.encode_delta_discrete">[docs]</a><span class="k">def</span> <span class="nf">encode_delta_discrete</span><span class="p">(</span><span class="n">elapsed_seconds</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Encode deltas into discrete buckets indicating:</span>
<span class="sd">        1. if elapsed_days &lt;= 1 day</span>
<span class="sd">        2. if elapsed_days &lt;= 1 week</span>
<span class="sd">        3. if elapsed_days &lt;= 30 days (1 month)</span>
<span class="sd">        4. if elapsed_days &lt;= 60 days (2 months)</span>
<span class="sd">        5. if elapsed_days &lt;= 90 days (3 months)</span>
<span class="sd">        6. if elapsed_days &lt;= 182 days (half-a-year)</span>
<span class="sd">        7. if elapsed_days &lt;= 365 days (1 year)</span>
<span class="sd">        8. if elapsed_days &lt;= 730 days (2 years)</span>

<span class="sd">    :param elapsed_seconds: number of seconds between this clinical snapshot and the previous</span>
<span class="sd">    :return: 8-dimensional discrete binary representation of elapsed_seconds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">elapsed_days</span> <span class="o">=</span> <span class="n">elapsed_seconds</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">/</span> <span class="mi">24</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">elapsed_days</span> <span class="o">&lt;=</span> <span class="n">bucket</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">bucket</span> <span class="ow">in</span> <span class="n">DELTA_BUCKETS</span><span class="p">]</span></div>


<span class="c1"># We use the size attribute to denote how many dimensions this delta encoding will have</span>
<span class="n">encode_delta_discrete</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">DELTA_BUCKETS</span><span class="p">)</span>


<div class="viewcode-block" id="encode_delta_continuous"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.encode_delta_continuous">[docs]</a><span class="k">def</span> <span class="nf">encode_delta_continuous</span><span class="p">(</span><span class="n">elapsed_seconds</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Encode deltas into discrete buckets</span>

<span class="sd">    :param elapsed_seconds: number of seconds between this clinical snapshot and the previous</span>
<span class="sd">    :return: tanh(log(elapsed days + 1))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">elapsed_days</span> <span class="o">=</span> <span class="n">elapsed_seconds</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">/</span> <span class="mi">60</span> <span class="o">/</span> <span class="mi">24</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">elapsed_days</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span></div>


<span class="c1"># We use the size attribute to denote how many dimensions this delta encoding will have</span>
<span class="n">encode_delta_continuous</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>


<div class="viewcode-block" id="Vocabulary"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Vocabulary">[docs]</a><span class="k">class</span> <span class="nc">Vocabulary</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A bi-directional lookup table between categorical terms and integer term ids.</span>
<span class="sd">    Term ids are contiguous, and start from 0.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        terms (list): a list of terms in the vocabulary; maps term IDs to terms</span>
<span class="sd">        term_index (dict): a dict mapping terms to their term ID</span>
<span class="sd">        term_frequencies (list): a list mapping term IDs to term frequencies</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">term_index</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Text</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">term_frequencies</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="n">Text</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">terms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">return_unk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a vocabulary from a given term_index, term_frequency and term list</span>

<span class="sd">        :param term_index (dict, optional): dictionary mapping terms to integer term ids</span>
<span class="sd">            (term ids must start from zero and be contiguous)</span>
<span class="sd">        :param term_frequencies: a dict or list associating each term with its frequency. If passed as a dict,</span>
<span class="sd">            each key must be a term and each value must be a positive integer indicating the frequency of that term.</span>
<span class="sd">            If passed as a list,  each entry in the list is assumed to be a positive integer indicating the frequency</span>
<span class="sd">            of the term whose term ID matches the index of that entry</span>
<span class="sd">        :param terms: a list of terms where the index of each term is the term ID of that term</span>
<span class="sd">        :param return_unk: whether the unknown term symbol should be returned when attempting to access</span>
<span class="sd">            out-of-vocabulary terms from this Vocabulary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">terms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terms</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">term_frequencies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term_frequencies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Convert term -&gt; frequency dict to term ID -&gt; frequency list</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">term_frequencies</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term_frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">term</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">term_frequencies</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">term_frequencies</span><span class="p">[</span><span class="n">term_index</span><span class="p">[</span><span class="n">term</span><span class="p">]]</span> <span class="o">=</span> <span class="n">freq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term_frequencies</span> <span class="o">=</span> <span class="n">term_frequencies</span>

        <span class="k">if</span> <span class="n">term_index</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term_index</span> <span class="o">=</span> <span class="n">term_index</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">return_unk</span> <span class="o">=</span> <span class="n">return_unk</span>

<div class="viewcode-block" id="Vocabulary.from_tsv"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Vocabulary.from_tsv">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_tsv</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                 <span class="n">vocabulary_file</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="n">add_unk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">return_unk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">max_vocab_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads a Vocabulary object from a given vocabulary TSV file path.</span>

<span class="sd">        The TSV file is assumed to be formatted as follows::</span>

<span class="sd">            [term]\t[frequency]</span>

<span class="sd">        such that the line number indicates the ID of the ``[term]`` on each line, ``[frequency]`` indicates the number</span>
<span class="sd">        of occurrences of that term in the training dataset, and terms are listed in descending order of their</span>
<span class="sd">        frequency.</span>

<span class="sd">        :param vocabulary_file: path to the TSV-formatted vocabulary file to load</span>
<span class="sd">        :param add_unk: whether to add the unknown term symbol the vocabulary (set to false if vocabulary</span>
<span class="sd">            already includes the unknown term symbol)</span>
<span class="sd">        :param return_unk: whether this Vocabulary object should return the unknown term symbol or raise a KeyError</span>
<span class="sd">            when asked to lookup out-of-vocabulary terms</span>
<span class="sd">        :param max_vocab_size: maximum vocabulary size. When loading from the disk, only the top max_vocab_size</span>
<span class="sd">            most-frequent terms will be retained. All other terms will be associated with the unknown term symbol (and</span>
<span class="sd">            their frequency will included in the unknown symbol&#39;s frequency). If None all terms are loaded.</span>
<span class="sd">        :return: a new Vocabulary object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">term_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">term_frequencies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">add_unk</span><span class="p">:</span>
            <span class="n">term_index</span><span class="p">[</span><span class="n">_UNK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">term_frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_UNK</span><span class="p">)</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">vocabulary_file</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">vocabulary</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm</span><span class="p">(</span><span class="n">vocabulary</span><span class="o">.</span><span class="n">readlines</span><span class="p">(),</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Loading vocabulary&#39;</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">max_vocab_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_vocab_size</span><span class="p">:</span>
                    <span class="n">term</span><span class="p">,</span> <span class="n">frequency</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">term_index</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span>
                    <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
                    <span class="n">term_frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">frequency</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">frequency</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
                    <span class="n">term_frequencies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">int</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">term_index</span><span class="p">,</span> <span class="n">term_frequencies</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">return_unk</span><span class="o">=</span><span class="n">return_unk</span><span class="p">)</span></div>

<div class="viewcode-block" id="Vocabulary.from_terms"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Vocabulary.from_terms">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_terms</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span>
                   <span class="n">terms</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Text</span><span class="p">],</span>
                   <span class="n">add_unk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                   <span class="n">return_unk</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                   <span class="n">max_vocab_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a vocabulary from an iterable of (possibly duplicate) terms.</span>

<span class="sd">        Unlike from_tsv, if max_vocab_size is specified the vocabulary will be created from the first max_vocab_size</span>
<span class="sd">        encountered unique terms, rather than the top max_vocab_size most frequent terms</span>

<span class="sd">        :param terms: iterable containing terms to add to the vocabulary</span>
<span class="sd">        :param add_unk: whether the unknown term symbol should be added to the vocabulary</span>
<span class="sd">        :param return_unk: whether this Vocabulary should return the unknown term symbol or raise KeyError when</span>
<span class="sd">            looking up out-of-vocabulary terms</span>
<span class="sd">        :param max_vocab_size: maximum vocabulary size. Unlike from_tsv, if max_vocab_size is specified, the vocabulary</span>
<span class="sd">            will be created from the first max_vocab_size encountered unique terms, rather than the top max_vocab_size</span>
<span class="sd">            most frequent terms.</span>
<span class="sd">        :return: a shiny new Vocabulary object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">term_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">term_frequencies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">vocab_terms</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">add_unk</span><span class="p">:</span>
            <span class="n">term_index</span><span class="p">[</span><span class="n">_UNK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">term_frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">vocab_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_UNK</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">term_index</span><span class="p">:</span>
                <span class="n">term_frequencies</span><span class="p">[</span><span class="n">term_index</span><span class="p">[</span><span class="n">term</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">max_vocab_size</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_vocab_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">term_index</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vocab_terms</span><span class="p">)</span>
                <span class="n">term_frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">vocab_terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">add_unk</span><span class="p">:</span>
                <span class="n">term_frequencies</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">term_index</span><span class="p">,</span> <span class="n">term_frequencies</span><span class="p">,</span> <span class="n">terms</span><span class="p">,</span> <span class="n">return_unk</span><span class="o">=</span><span class="n">return_unk</span><span class="p">)</span></div>

<div class="viewcode-block" id="Vocabulary.encode_term"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Vocabulary.encode_term">[docs]</a>    <span class="k">def</span> <span class="nf">encode_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encode the given term using this vocabulary.</span>

<span class="sd">        Terms included in this vocabulary will be returned as-is. Out-of-vocabulary terms will be returned as the</span>
<span class="sd">        unknown term symbol if this Vocabulary was created with  return_unk=True. Otherwise, encoding out-of-vocabulary</span>
<span class="sd">        terms will raise a KeyError.</span>

<span class="sd">        :param term: term to encode</span>
<span class="sd">        :return:  term or unknown term symbol</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">term</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_unk</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_UNK</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Term </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">term</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> not found in vocabulary&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Vocabulary.encode_term_id"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Vocabulary.encode_term_id">[docs]</a>    <span class="k">def</span> <span class="nf">encode_term_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Encode the given term ID using this vocabulary.</span>

<span class="sd">        Term IDs included in this vocabulary will be returned as-is. Out-of-vocabulary term iss will be returned as the</span>
<span class="sd">        unknown term symbol ID (0) if this Vocabulary was created with return_unk=True. Otherwise, encoding</span>
<span class="sd">        out-of-vocabulary term IDs will raise a KeyError.</span>

<span class="sd">        :param term_id: term ID to encode</span>
<span class="sd">        :return:  term_id or unknown term symbol ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">term_id</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">term_id</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_unk</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_index</span><span class="p">[</span><span class="n">_UNK</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Term ID &#39;</span> <span class="o">+</span> <span class="n">term_id</span> <span class="o">+</span> <span class="s1">&#39; not valid for vocabulary&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Vocabulary.lookup_term_by_term_id"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Vocabulary.lookup_term_by_term_id">[docs]</a>    <span class="k">def</span> <span class="nf">lookup_term_by_term_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look-up term by term by given term ID.</span>

<span class="sd">        Raises KeyException for invalid term IDs.</span>

<span class="sd">        :param term_id: ID of term to lookup</span>
<span class="sd">        :return: term associated with term_id in this vocabulary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">[</span><span class="n">term_id</span><span class="p">]</span></div>

<div class="viewcode-block" id="Vocabulary.lookup_term_id_by_term"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Vocabulary.lookup_term_id_by_term">[docs]</a>    <span class="k">def</span> <span class="nf">lookup_term_id_by_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Look-up term by term ID for given term.</span>

<span class="sd">        Returns unknown term symbol if this vocabulary was created with return_unk=True, otherwise raises KeyError</span>

<span class="sd">        :param term: term to lookup</span>
<span class="sd">        :return: term ID associated with given term in this vocabulary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_unk</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_index</span><span class="o">.</span><span class="n">get</span><span class="p">[</span><span class="n">_UNK</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_index</span><span class="p">[</span><span class="n">term</span><span class="p">]</span></div>

<div class="viewcode-block" id="Vocabulary.add_term"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Vocabulary.add_term">[docs]</a>    <span class="k">def</span> <span class="nf">add_term</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">term</span><span class="p">:</span> <span class="n">Text</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds the given term to this vocabulary and returns its ID.</span>

<span class="sd">        If the given term is already in this vocabulary, its frequency will be updated. This method ignores any</span>
<span class="sd">        maximum_vocabulary_size given when creating the vocabulary.</span>

<span class="sd">        :param term: term to add</span>
<span class="sd">        :return: new or existing ID of the given term in this vocabulary</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">term</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_index</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term_frequencies</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">term_index</span><span class="p">[</span><span class="n">term</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term_index</span><span class="p">[</span><span class="n">term</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">term_frequencies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">term_index</span><span class="p">[</span><span class="n">term</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of unique terms in this vocabulary&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">terms</span><span class="p">)</span></div>


<div class="viewcode-block" id="Chronology"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Chronology">[docs]</a><span class="k">class</span> <span class="nc">Chronology</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Representation of a single Chronology.</span>

<span class="sd">    Note: unlike the AMIA paper, this chronology includes an additional vector indicating the label (i.e., pneumonia)</span>
<span class="sd">    for each snapshot.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        deltas: list/array containing elapsed time (in days) since previous snapshot where delta[0] = 0</span>
<span class="sd">        labels: list/array indicating the (binary) label (e.g., pneumonia) for each snapshot</span>
<span class="sd">        snapshots: matrix indicating the observations in each snapshot such that each column indicates a snapshot, and</span>
<span class="sd">        each row j indicates the j-th observation in that snapshot</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deltas</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">snapshots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Creates a Chronology from the given deltas, labels, and snapshots.</span>
<span class="sd">        Note: no defensive copies are made!</span>

<span class="sd">        :param deltas: list/array containing elapsed time (in days) since previous snapshot where delta[0] = 0</span>
<span class="sd">        :param labels: list/array indicating the (binary) label (e.g., pneumonia) for each snapshot</span>
<span class="sd">        :param snapshots: matrix indicating the observations in each snapshot such that each column indicates a snapshot</span>
<span class="sd">            and each row j indicates the j-th observation in that snapshot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltas</span> <span class="o">=</span> <span class="n">deltas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span> <span class="o">=</span> <span class="n">snapshots</span>

<div class="viewcode-block" id="Chronology.truncate"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Chronology.truncate">[docs]</a>    <span class="k">def</span> <span class="nf">truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">truncate_length</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Truncates this chronology to end at the given length (i.e., returns a temporal slice).</span>

<span class="sd">        :param truncate_length: the new length of this chronology (if negative, the new length will be</span>
<span class="sd">            len(chronology) - abs(truncate_length)</span>
<span class="sd">        :return: truncated view of this chronology</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Chronology</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltas</span><span class="p">[:</span><span class="n">truncate_length</span><span class="p">],</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[:</span><span class="n">truncate_length</span><span class="p">],</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[:</span><span class="n">truncate_length</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of snapshots in this chronology&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deltas</span><span class="p">)</span></div>


<div class="viewcode-block" id="Cohort"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Cohort">[docs]</a><span class="k">class</span> <span class="nc">Cohort</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Data structure containing the chronologies and vocabulary associated with a cohort of patients.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        vocabulary (Vocabulary): the vocabulary of observations reported for this cohort</span>
<span class="sd">        patient_vocabulary (Vocabulary): a vocabulary mapping patients to contiguous integer IDs</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">patient_chronologies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vocabulary</span><span class="o">=</span><span class="n">Vocabulary</span><span class="p">(),</span> <span class="n">patient_vocabulary</span><span class="o">=</span><span class="n">Vocabulary</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;Create a (possibly-empty) Chronology.</span>

<span class="sd">        :param patient_chronologies: list of Chronology vectors associated with each patient. Index of each patient</span>
<span class="sd">            in this list should correspond to the ID for that patient in the patient_vocabulary</span>
<span class="sd">        :param vocabulary(Vocabulary): vocabulary of observations associated with this chronology</span>
<span class="sd">        :param patient_vocabulary(Vocabulary): vocabulary of patient IDs associated with this chronology</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vocabulary</span> <span class="o">=</span> <span class="n">vocabulary</span>
        <span class="k">if</span> <span class="n">patient_chronologies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_patient_chronologies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_patient_chronologies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">patient_chronologies</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_patient_vocabulary</span> <span class="o">=</span> <span class="n">patient_vocabulary</span>

<div class="viewcode-block" id="Cohort.from_dict"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Cohort.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">cohort</span><span class="p">,</span> <span class="n">vocabulary</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a chronology from a given dict of patient id to chronologies and vocabulary of observations.</span>

<span class="sd">        :param cohort: a dict associating each patient in the cohort with a list of his or her chronologies</span>
<span class="sd">        :param vocabulary: vocabulary of observations documented in this cohort</span>
<span class="sd">        :return: Shiny new Cohort object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a patient vocabulary to associate external patient IDs to internal, contiguous integer IDs</span>
        <span class="n">patient_vocabulary</span> <span class="o">=</span> <span class="n">Vocabulary</span><span class="o">.</span><span class="n">from_terms</span><span class="p">(</span><span class="n">cohort</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                                                   <span class="n">add_unk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_unk</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                                   <span class="n">max_vocab_size</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Create a nested array associated each internal patient ID to his or her chronologies</span>
        <span class="n">patients</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">subject_id</span><span class="p">,</span> <span class="n">admissions</span> <span class="ow">in</span> <span class="n">cohort</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">patient_vocabulary</span><span class="o">.</span><span class="n">add_term</span><span class="p">(</span><span class="n">subject_id</span><span class="p">)</span>
            <span class="n">patients</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">admissions</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">patients</span><span class="p">,</span> <span class="n">vocabulary</span><span class="p">,</span> <span class="n">patient_vocabulary</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cohort.from_disk"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Cohort.from_disk">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_disk</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">patient_vectors</span><span class="p">,</span> <span class="n">vocabulary</span><span class="p">,</span> <span class="n">max_vocab_size</span><span class="o">=</span><span class="mi">50</span><span class="n">_000</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load cohort from a given chronology file and vocabulary file or Vocabulary object.</span>

<span class="sd">        The format of this file is assumed to be as follows::</span>

<span class="sd">            [external_patient_id]\t[chronology]</span>

<span class="sd">        where each ``[chronology]`` is encoded as as sequence of snapshots::</span>

<span class="sd">            [[snapshot]\t...]</span>

<span class="sd">        and each ``[snapshot]`` is encoded as::</span>

<span class="sd">            [delta] [label] [observation IDs..]</span>

<span class="sd">        Note that snapshots are delimited by *spaces*, label must be &#39;true&#39; or &#39;false&#39;, delta is represented in seconds</span>
<span class="sd">        since previous chronology, and observation IDs should be the IDs associated with the observation in the given</span>
<span class="sd">        vocabulary file.</span>

<span class="sd">        For example, the line::</span>

<span class="sd">            11100004a   0 false 1104 1105 2300 25001    86400 false 1104 2300   172800 true 1104 2300 3500</span>

<span class="sd">        would indicate that patient with external ID &#39;11100004a&#39; had a chronology including 3 snapshots</span>
<span class="sd">        where:</span>

<span class="sd">        * the first snapshot was negative for pneumonia, had a delta of 0, and contained only three clinical</span>
<span class="sd">          observations: those associated with vocabulary terms 1104, 1105, 2300, and 25001;</span>
<span class="sd">        * the second snapshot was negative for pneumonia, had a delta of 86400 seconds (1 day), and included only</span>
<span class="sd">          two clinical observations: 1104 and 2300</span>
<span class="sd">        * the third snapshot was positive for pneumonia, had a delta of 172800 seconds (2 days), and included only</span>
<span class="sd">          three clinical observations: 1104, 2300, and 3500</span>

<span class="sd">        The vocabulary file is assumed to be formatted as follows::</span>

<span class="sd">            [observation]\t[frequency]</span>

<span class="sd">        where the line number indicates the ID of the observation int he chronology (e.g., 1104), ``[observation]`` is a</span>
<span class="sd">        human-readable string describing the observation, and ``[frequency]`` is the frequency of that observation in</span>
<span class="sd">        the dataset (this value is only important if specifying a max_vocabulary_size as terms will be sorted in</span>
<span class="sd">        descending frequency before the cut-off is made)</span>

<span class="sd">        Note: as described in the AMIA paper , chronologies are truncated to terminate at the first positive label.</span>
<span class="sd">        Chronologies in which the first snapshot is positive or in which no snapshot is positive are discarded.</span>

<span class="sd">        :param patient_vectors: file containing for chronology vectors for the cohort</span>
<span class="sd">        :param vocabulary: file containing the vocabulary used to generate chronology vectors or an existing Vocabulary</span>
<span class="sd">            object</span>
<span class="sd">        :param max_vocab_size: maximum vocabulary size (if given, only the top max_vocabulary_size most frequent</span>
<span class="sd">            observations will be retained, and all other observations will mapped to the unknown term symbol &quot;_UNK&quot;)</span>
<span class="sd">        :return: Cohort object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Load vocabulary from file if we weren&#39;t already given a Vocabulary object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vocabulary</span><span class="p">,</span> <span class="n">Vocabulary</span><span class="p">):</span>
            <span class="n">vocabulary</span> <span class="o">=</span> <span class="n">Vocabulary</span><span class="o">.</span><span class="n">from_tsv</span><span class="p">(</span><span class="n">vocabulary</span><span class="p">,</span> <span class="n">max_vocab_size</span><span class="o">=</span><span class="n">max_vocab_size</span><span class="p">)</span>

        <span class="c1"># We represent our cohort as a dictionary of external_patient_id to lists of one or more chronologies</span>
        <span class="n">cohort</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Keep track of how many chronologies we have discarded</span>
        <span class="n">filtered_chronologies</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">patient_vectors</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">vector_file</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">vector_file</span><span class="o">.</span><span class="n">readlines</span><span class="p">(),</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Loading chronologies&#39;</span><span class="p">):</span>
                <span class="c1"># For whatever reason windows likes to add newlines to chronologies files when they are opened with</span>
                <span class="c1"># certain editors, so we need to strip them</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

                <span class="c1"># Load the subject id and list of snapshots</span>
                <span class="c1"># Each chronology is represented by [external_patient_id]\t[[snapshots]\t...]</span>
                <span class="n">subject_id</span><span class="p">,</span> <span class="o">*</span><span class="n">snapshots</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>

                <span class="c1"># If this is a new subject, initialize his or her list of chronologies to be empty</span>
                <span class="k">if</span> <span class="n">subject_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cohort</span><span class="p">:</span>
                    <span class="n">cohort</span><span class="p">[</span><span class="n">subject_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="c1"># Parse snapshots to create a chronology</span>
                <span class="n">deltas</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">observations</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">snapshot</span> <span class="ow">in</span> <span class="n">snapshots</span><span class="p">:</span>
                    <span class="c1"># Each snapshot is encoded as [delta] [label] [[observation ids] ...]</span>
                    <span class="n">delta</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="o">*</span><span class="n">observation_ids</span> <span class="o">=</span> <span class="n">snapshot</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                    <span class="n">deltas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">delta</span><span class="p">))</span>

                    <span class="c1"># Parse labels</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;true&#39;</span><span class="p">:</span>
                        <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">label</span> <span class="o">==</span> <span class="s1">&#39;false&#39;</span><span class="p">:</span>
                        <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Encountered invalid label </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">label</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">)</span>

                    <span class="c1"># Encode observations  using our vocabulary (that is, associated any out-of-vocabulary observations</span>
                    <span class="c1"># with the unknown term symbol _UNK</span>
                    <span class="n">observations</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">vocabulary</span><span class="o">.</span><span class="n">encode_term_id</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">word_id</span><span class="p">))</span> <span class="k">for</span> <span class="n">word_id</span> <span class="ow">in</span> <span class="n">observation_ids</span><span class="p">])</span>

                    <span class="c1"># Terminate after first positive label</span>
                    <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="c1"># We only care about patients who were</span>
                <span class="c1"># (1) not diagnosed in their first snapshot,</span>
                <span class="c1"># (2) had at least two snapshots, and</span>
                <span class="c1"># (3) were eventually diagnosed</span>
                <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">deltas</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># We discard the delta and label from the first snapshot (since we can&#39;t predict the first snapshot)</span>
                    <span class="c1"># and discard the observations in the final snapshot (since that is when we are trying to predict).</span>
                    <span class="c1"># Unlike the AMIA paper, we shift our deltas (and labels) within the chronology datastructure</span>
                    <span class="c1"># such that label[t] is the label we are trying to predict given snapshot[t] and delta[t]</span>
                    <span class="c1"># is the elapsed time from snapshot[t] to the label[t] prediction</span>
                    <span class="n">cohort</span><span class="p">[</span><span class="n">subject_id</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Chronology</span><span class="p">(</span><span class="n">deltas</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">observations</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">filtered_chronologies</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">filtered_patients</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">subject_id</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">cohort</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="c1"># Any patients with zero chronologies after filtering are removed</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cohort</span><span class="p">[</span><span class="n">subject_id</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">filtered_patients</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">del</span> <span class="n">cohort</span><span class="p">[</span><span class="n">subject_id</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Loaded cohort of </span><span class="si">%d</span><span class="s1"> patients with </span><span class="si">%d</span><span class="s1"> visits (after filtering </span><span class="si">%d</span><span class="s1"> patients and </span><span class="si">%d</span><span class="s1"> visits)&#39;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">cohort</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>  <span class="c1"># Number of unique patients with chronologies</span>
            <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">cohort</span><span class="o">.</span><span class="n">values</span><span class="p">()]),</span>  <span class="c1"># Number of chronologies across all patients</span>
            <span class="n">filtered_patients</span><span class="p">,</span>  <span class="c1"># Number of patients removed by chronology filtering</span>
            <span class="n">filtered_chronologies</span><span class="p">)</span>  <span class="c1"># Number of chronologies removed across all patients</span>
        <span class="p">)</span>

        <span class="c1"># Convert the dict of external id -&gt; [chronology] list into a Chronology object</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">cohort</span><span class="p">,</span> <span class="n">vocabulary</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of chronologies in this cohort&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_patient_chronologies</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subject_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given an iterable or single external id, return the sub-cohort of patients associated with that/those ids&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subject_id</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_patient_vocabulary</span><span class="o">.</span><span class="n">lookup_term_id_by_term</span><span class="p">(</span><span class="n">term</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">subject_id</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Cohort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_patient_chronologies</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">vocabulary</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">_patient_vocabulary</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Cohort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_patient_chronologies</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_patient_vocabulary</span><span class="o">.</span><span class="n">lookup_term_by_term_id</span><span class="p">(</span><span class="n">subject_id</span><span class="p">)],</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">vocabulary</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">_patient_vocabulary</span><span class="p">)</span>

<div class="viewcode-block" id="Cohort.patients"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Cohort.patients">[docs]</a>    <span class="k">def</span> <span class="nf">patients</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a list of external patient IDs indicating the members of this cohort&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patient_vocabulary</span><span class="o">.</span><span class="n">terms</span></div>

<div class="viewcode-block" id="Cohort.chronologies"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Cohort.chronologies">[docs]</a>    <span class="k">def</span> <span class="nf">chronologies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a flattened list of all chronologies in this cohort&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">chronology</span> <span class="k">for</span> <span class="n">patient</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patient_chronologies</span> <span class="k">for</span> <span class="n">chronology</span> <span class="ow">in</span> <span class="n">patient</span><span class="p">]</span></div>

<div class="viewcode-block" id="Cohort.items"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Cohort.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns tuples of subject IDs to list of chronologies (for dictionary-like iteration)&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">subject_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patient_vocabulary</span><span class="o">.</span><span class="n">terms</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">subject_id</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">subject_id</span><span class="p">])</span></div>

<div class="viewcode-block" id="Cohort.balance_chronologies"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Cohort.balance_chronologies">[docs]</a>    <span class="k">def</span> <span class="nf">balance_chronologies</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a view of this cohort with balanced chronologies.</span>

<span class="sd">        Specifically, return a copy of this cohort in which each patient has an equal number of positive and</span>
<span class="sd">        negative chronology examples for training.</span>

<span class="sd">        As described in the AMIA paper, we use each chronology as-is as a positive example and create a negative example</span>
<span class="sd">        by predicting the label associated with the second-to-last chronology (which is always negative)</span>
<span class="sd">        from the previous chronologies</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">balanced_chronologies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">patient</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patient_chronologies</span><span class="p">:</span>
            <span class="c1"># We interleave positive and negative examples</span>
            <span class="n">balanced_visits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">patient</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
            <span class="c1"># Even indicates are positive examples</span>
            <span class="n">balanced_visits</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">patient</span>
            <span class="c1"># Randomly truncate visits to end before the final snapshot to create negative examples</span>
            <span class="n">negative_examples</span> <span class="o">=</span> <span class="p">[</span><span class="n">chronology</span><span class="o">.</span><span class="n">truncate</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chronology</span><span class="p">)))</span> <span class="k">for</span> <span class="n">chronology</span> <span class="ow">in</span> <span class="n">patient</span><span class="p">]</span>
            <span class="c1"># Odd indices are negative examples</span>
            <span class="n">balanced_visits</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">negative_examples</span>
            <span class="n">balanced_chronologies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">balanced_visits</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Cohort</span><span class="p">(</span><span class="n">balanced_chronologies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vocabulary</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_patient_vocabulary</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cohort.make_simple_classification"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Cohort.make_simple_classification">[docs]</a>    <span class="k">def</span> <span class="nf">make_simple_classification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_encoder</span><span class="o">=</span><span class="n">encode_delta_continuous</span><span class="p">,</span> <span class="n">final_only</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Represent this cohort as a data and label vector amenable to Sci-kit learn.</span>

<span class="sd">        :param delta_encoder: type of delta encoding to use</span>
<span class="sd">        :param final_only: whether to convert each pair of successive chronologies to an example (default) or to only</span>
<span class="sd">            take the final positive and negative examples</span>
<span class="sd">        :param kwargs:</span>
<span class="sd">        :return: an observation matrix X such that each row indicates a snapshot and each column indicates the</span>
<span class="sd">            presence of absence of that feature (with deltas encoded as an extra feature) and a label vector y</span>
<span class="sd">            indicating the label in the next snapshot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Shuffle chronologies for science</span>
        <span class="n">chronologies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chronologies</span><span class="p">())</span>
        <span class="n">vocabulary_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vocabulary</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">chronology</span> <span class="ow">in</span> <span class="n">chronologies</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">final_only</span><span class="p">:</span>
                <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">chronology</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chronology</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">:</span>
                <span class="c1"># Convert sequence of observations into bag-of-observations vector</span>
                <span class="n">bow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">vocabulary_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">bow</span><span class="p">[</span><span class="n">chronology</span><span class="o">.</span><span class="n">docs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="c1"># Deltas and labels are already time-shifted when the cohort is created, so we don&#39;t need to shift them</span>
                <span class="c1"># here</span>
                <span class="n">deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">delta_encoder</span><span class="p">(</span><span class="n">chronology</span><span class="o">.</span><span class="n">deltas</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span>
                <span class="n">x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">deltas</span><span class="p">,</span> <span class="n">bow</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="n">y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chronology</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cohort.make_epoch_batches"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.Cohort.make_epoch_batches">[docs]</a>    <span class="k">def</span> <span class="nf">make_epoch_batches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">max_snapshot_size</span><span class="p">,</span> <span class="n">max_chron_len</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                           <span class="n">delta_encoder</span><span class="o">=</span><span class="n">encode_delta_continuous</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create shuffled, equal-size mini-batches from the entire cohort.</span>

<span class="sd">        :param batch_size: size of mini-batches (e.g., number of chronologies in each batch)</span>
<span class="sd">        :param max_snapshot_size: maximum number of observations to consider in each snapshot (will be trimmed/zero-padded)</span>
<span class="sd">        :param max_chron_len: maximum number of snapshots to consider in each chronology (will be trimmed/zero-padded)</span>
<span class="sd">        :param limit: take only the first limit mini-batches, rather than all mini-batches for the cohort</span>
<span class="sd">        :param delta_encoder: encoder to use for encoding deltas</span>
<span class="sd">        :param kwargs: unused extra arguments (makes calling this method less tedious)</span>
<span class="sd">        :return: a list of ChronologyBatch objects</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Shuffle chronologies</span>
        <span class="n">chronologies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chronologies</span><span class="p">())</span>

        <span class="c1"># Determine the number of batches we will produce</span>
        <span class="n">num_batches</span> <span class="o">=</span> <span class="n">chronologies</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">batch_size</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_batches</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_batches</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

        <span class="c1"># Throw away the last batch if its incomplete (shouldn&#39;t be an issue since we are permuting the order)</span>
        <span class="n">truncate_length</span> <span class="o">=</span> <span class="n">num_batches</span> <span class="o">*</span> <span class="n">batch_size</span>
        <span class="n">chronologies</span> <span class="o">=</span> <span class="n">chronologies</span><span class="p">[:</span><span class="n">truncate_length</span><span class="p">]</span>

        <span class="c1"># Split chronologies into mini-batches</span>
        <span class="n">batches</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">chronologies</span><span class="p">,</span> <span class="n">num_batches</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Encode each minibatch as a ChronologyBatch object</span>
        <span class="n">chronology_batches</span> <span class="o">=</span> <span class="p">[</span><span class="n">ChronologyBatch</span><span class="o">.</span><span class="n">from_chronologies</span><span class="p">(</span><span class="n">batch</span><span class="p">,</span>
                                                                <span class="n">max_snapshot_size</span><span class="p">,</span>
                                                                <span class="n">max_chron_len</span><span class="p">,</span>
                                                                <span class="n">delta_encoder</span><span class="p">)</span> <span class="k">for</span> <span class="n">batch</span> <span class="ow">in</span> <span class="n">batches</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">chronology_batches</span></div></div>


<div class="viewcode-block" id="ChronologyBatch"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.ChronologyBatch">[docs]</a><span class="k">class</span> <span class="nc">ChronologyBatch</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Represents a batch of chronologies as zero-padded equal-length numpy ndarrays</span>

<span class="sd">    Attributes:</span>
<span class="sd">        batch_size(int): number of chronologies in this batch</span>
<span class="sd">        deltas: [batch_size x max_seq_len x delta_encoding_size] 3-d float32 numpy array encoding deltas for each</span>
<span class="sd">            snapshot in each chronology in this batch</span>
<span class="sd">        seq_lens: [batch_size] 1-d int32 numpy array encoding the non-zero-padded length (number of snapshots) for each</span>
<span class="sd">            chronology in this batch</span>
<span class="sd">        labels: [batch_size] 1-d int32 numpy array encoding the label for the final prediction for each chronology in</span>
<span class="sd">            this batch</span>
<span class="sd">        snapshots: [batch_size x max_seq_len x max_snap_size] 3-d int32 numpy array encoding the clinical observations</span>
<span class="sd">            recorded for each snapshot in each chronology in this batch</span>
<span class="sd">        snapshot_sizes: [batch_size x max_seq_len] 2-d int32 numpy array encoding the number of clinical observations</span>
<span class="sd">            recorded for each snapshot in each chronology in this batch</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">,</span> <span class="n">deltas</span><span class="p">,</span> <span class="n">seq_lens</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">snapshots</span><span class="p">,</span> <span class="n">snapshot_sizes</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span> <span class="o">=</span> <span class="n">batch_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deltas</span> <span class="o">=</span> <span class="n">deltas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_lens</span> <span class="o">=</span> <span class="n">seq_lens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span> <span class="o">=</span> <span class="n">snapshots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_sizes</span> <span class="o">=</span> <span class="n">snapshot_sizes</span>

<div class="viewcode-block" id="ChronologyBatch.from_chronologies"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.ChronologyBatch.from_chronologies">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_chronologies</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">chronologies</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Chronology</span><span class="p">],</span> <span class="n">max_snapshot_size</span><span class="p">,</span> <span class="n">max_chron_len</span><span class="p">,</span> <span class="n">delta_encoder</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create a zero-padded/trimmed ChronologyBatch from a given batch of Chronology objects</span>

<span class="sd">        :param chronologies: batch of Chronology objects</span>
<span class="sd">        :param max_snapshot_size: maximum number of observations for each chronology (used to trim/zero-pad)</span>
<span class="sd">        :param max_chron_len: maximum number of snapshots for each chronology (used to trim/zero-pad)</span>
<span class="sd">        :param delta_encoder: delta encoder to use</span>
<span class="sd">        :return: new ChronologyBatch object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Infer batch size from the number of chronologies given to this method</span>
        <span class="n">batch_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chronologies</span><span class="p">)</span>

        <span class="c1"># Zero-pad everything to the indicated maximum sizes</span>
        <span class="n">deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">max_chron_len</span><span class="p">,</span> <span class="n">delta_encoder</span><span class="o">.</span><span class="n">size</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">seq_lens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">snapshots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">max_chron_len</span><span class="p">,</span> <span class="n">max_snapshot_size</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">snapshot_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">([</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">max_chron_len</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">chronology</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chronologies</span><span class="p">):</span>
            <span class="c1"># Get the trimmed but non-padded length of this chronology</span>
            <span class="n">seq_end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chronology</span><span class="o">.</span><span class="n">deltas</span><span class="p">),</span> <span class="n">max_chron_len</span><span class="p">)</span>
            <span class="n">seq_lens</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">seq_end</span>

            <span class="c1"># Convert deltas using delta encoder</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">delta</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chronology</span><span class="o">.</span><span class="n">deltas</span><span class="p">[:</span><span class="n">seq_end</span><span class="p">]):</span>
                <span class="n">deltas</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">delta_encoder</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>

            <span class="c1"># Use final label as the prediction label for this chronology</span>
            <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">chronology</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">seq_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Convert sequences of observations to sequences of one-hots</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">snapshot</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">chronology</span><span class="o">.</span><span class="n">snapshots</span><span class="p">[:</span><span class="n">seq_end</span><span class="p">]):</span>
                <span class="c1"># Get the trimmed but non-padded length of this snapshot</span>
                <span class="n">snapshot_size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">snapshot</span><span class="p">),</span> <span class="n">max_snapshot_size</span><span class="p">)</span>
                <span class="n">snapshot_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">snapshot_size</span>

                <span class="c1"># Take the first snapshot_size observations</span>
                <span class="n">snapshots</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="p">:</span><span class="n">snapshot_size</span><span class="p">]</span> <span class="o">=</span> <span class="n">snapshot</span><span class="p">[:</span><span class="n">snapshot_size</span><span class="p">]</span>

        <span class="c1"># Convert this into a ChronologyBatch object</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">batch_size</span><span class="p">,</span> <span class="n">deltas</span><span class="p">,</span> <span class="n">seq_lens</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">snapshots</span><span class="p">,</span> <span class="n">snapshot_sizes</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChronologyBatch.perturb_labels"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.ChronologyBatch.perturb_labels">[docs]</a>    <span class="k">def</span> <span class="nf">perturb_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a copy of this ChronologyBatch with the labels shuffled across chronologies&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ChronologyBatch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">batch_size</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">deltas</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">seq_lens</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">),</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">,</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_sizes</span><span class="p">)</span></div>

<div class="viewcode-block" id="ChronologyBatch.feed"><a class="viewcode-back" href="../../../src.data.html#src.data.scribe_data.ChronologyBatch.feed">[docs]</a>    <span class="k">def</span> <span class="nf">feed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="n">CANTRIPModel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Feed this chronology batch to a CANTRIPModel object</span>

<span class="sd">        :param model: CANTRIP model which will be fed the data in this batch</span>
<span class="sd">        :return: a feed dict for use with TensorFlow session.run()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">model</span><span class="o">.</span><span class="n">observations</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshots</span><span class="p">,</span>
                <span class="n">model</span><span class="o">.</span><span class="n">deltas</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">deltas</span><span class="p">,</span>
                <span class="n">model</span><span class="o">.</span><span class="n">snapshot_sizes</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">snapshot_sizes</span><span class="p">,</span>
                <span class="n">model</span><span class="o">.</span><span class="n">seq_lengths</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_lens</span><span class="p">,</span>
                <span class="n">model</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">}</span></div></div>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">CANTRIP</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Travis R. Goodwin.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.11</a>
      
    </div>

    

    
  </body>
</html>